exports[`examples > fibonacci.plz > --input=-1 > stderr 1`] = `

`;

exports[`examples > fibonacci.plz > --input=-1 > stdout 1`] = `
"--input must be a natural number"

`;

exports[`examples > fibonacci.plz > --input=0 > stderr 1`] = `

`;

exports[`examples > fibonacci.plz > --input=0 > stdout 1`] = `
0

`;

exports[`examples > fibonacci.plz > --input=1 > stderr 1`] = `

`;

exports[`examples > fibonacci.plz > --input=1 > stdout 1`] = `
1

`;

exports[`examples > fibonacci.plz > --input=10 > stderr 1`] = `

`;

exports[`examples > fibonacci.plz > --input=10 > stdout 1`] = `
55

`;

exports[`examples > fibonacci.plz > --input=2 > stderr 1`] = `

`;

exports[`examples > fibonacci.plz > --input=2 > stdout 1`] = `
1

`;

exports[`examples > fibonacci.plz > --input=\"not a number\" > stderr 1`] = `

`;

exports[`examples > fibonacci.plz > --input=\"not a number\" > stdout 1`] = `
"--input must be a natural number"

`;

exports[`examples > fibonacci.plz > roundtripped syntax tree 1`] = `
{
  fibonacci: n => @if {
    (:n < 2)
    then: :n
    else: :fibonacci(:n - 1) + :fibonacci(:n - 2)
  }
  input: @runtime {
    context => :context.arguments.lookup(input)
  }
  output: :input match {
    none: _ => "missing --input argument"
    some: input => @if {
      :natural_number.is(:input)
      then: :fibonacci(:input)
      else: "--input must be a natural number"
    }
  }
}.output

`;

exports[`examples > fibonacci.plz > stderr 1`] = `

`;

exports[`examples > fibonacci.plz > stdout 1`] = `
"missing --input argument"

`;

exports[`examples > kitchen-sink.plz > roundtripped syntax tree 1`] = `
{
  foo: bar
  bar: :foo
  sky_is_blue: :boolean.not(false)
  colors: {
    red
    green
    blue
  }
  two: 1 + 1
  add_one: :integer.add(1)
  three: :add_one(:two)
  function: x => {
    value: :x
  }
  conditional_value: :function(@if {
    :sky_is_blue
    :two
    :three
  })
  side_effect: @runtime {
    context => :context.log("this goes to stderr")
  }
}

`;

exports[`examples > kitchen-sink.plz > stderr 1`] = `
"this goes to stderr"

`;

exports[`examples > kitchen-sink.plz > stdout 1`] = `
{
  foo: bar
  bar: bar
  sky_is_blue: true
  colors: {
    red
    green
    blue
  }
  two: 2
  add_one: :integer.add(1)
  three: 3
  function: x => {
    value: :x
  }
  conditional_value: {
    value: 2
  }
  side_effect: "this goes to stderr"
}

`;

exports[`examples > lookup-environment-variable.plz > roundtripped syntax tree 1`] = `
@runtime {
  context => :context.arguments.lookup(variable) match {
    none: {}
    some: :context.environment.lookup >> :match({
      none: {}
      some: :identity
    })
  }
}

`;

exports[`examples > lookup-environment-variable.plz > stderr 1`] = `

`;

exports[`examples > lookup-environment-variable.plz > stdout 1`] = `
{}

`;
